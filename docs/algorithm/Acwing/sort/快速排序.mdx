---
title: 快速排序
sidebar_label: 快速排序
hide_table_of_contents: false
---
[**Acwing链接**](https://www.acwing.com/activity/content/problem/content/819/)

快速排序的思路：
1. 随机选中序列中的一个元素，记为 x ，以此作为分界线
2. 进行排序，排序后要满足的结果是：在 x 左边的元素全部小于等于  x，在 x 右边的元素全部大于等于 x
3. 递归地对左右两边进行快速排序

这个思路的关键在于第二步：将比 x 小的元素全部放到左边，将比 x 大的数全部放到右边。这里采用双指针来完成这一步。

```cpp
//传入要排序的数组 q ,数组的最左边 l ,数组的最右边 r
void quick_sort(int q[], int l, int r){
    //确定分界点,取中间的点的值
    int x = q[(l+r)>>1];
    int i = l-1, j = r+1;
    
    //数组没有元素的时候，不用排序
    if(l >= r) return;
    //数组存在元素时,划分左右区域
    while(i<j){
        do i++; while(q[i]<x);
        do j--; while(q[j]>x);
        if(i<j) swap(q[i],q[j]);
    }
    //划分好之后，对左，右区域递归划分
    quick_sort(q,l,j);
    quick_sort(q,j+1,r);
}
```

:::tip 注意点1：代码中的`i++`和`j--`一定是在与 x 比较前执行的

如果是先比较，后进行`i++`和`j--`，可能会出现一种情况，举个例子：假如现在序列为 1 1 3 1 1，而 x = 2，第一轮循环之后 i = 2， j = 4，由于 3 > 2 和 1 < 2，所以 i 和 j 停下不再循环，此时将 q[i] 和 q[j] 调换位置之后，再进行 `i++` 和 `j--`，会发现 `i = j = 3`，循环就结束了，但是 q[3] 其实是没有被扫描过的，按照快排的思路，i 最后应该等于 4 而不是 3。

:::

:::tip 注意点2： i 与 j 停止移动的时候不一定是相等的，此时，q[i] 与 q[j] 并不一定会等于 x

例子：序列 1 1 1 2 3 4 1，取中间值为 x ，则 x = 2，在最后排序结束之后，i = 4， j = 3，序列此时为：1 1 1 1 3 4 2

:::